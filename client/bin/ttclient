#!/usr/bin/perl
use strict;

#    ttclient - The Robot Army client code.
#
#    Copyright (C) 2009 H5 Technologies, Ira Woodhead
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#  
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


use 5.006;
use strict;
use warnings;

use FileHandle;
use DBI;
use Digest::MD5 qw{ md5 md5_hex };
use LWP::UserAgent;
use HTTP::Request;
use Getopt::Long;
use POSIX 'setsid';
require 'lib/shared.pl';

my $scp = 'scp -q -o "ConnectTimeout 3"';

my %conf = readconf("conf/task.conf");
my @args = @ARGV;
@ARGV = ();
my $cmd = $conf{cmd};
die "Unknown task" unless 
  (grep { $cmd eq $_ } qw{ mapreduce exec });

$cmd = "tt$cmd";
$cmd = \&$cmd;
daemonize( @args );
setsvc( LWP::UserAgent->new, "http://$conf{master}:$conf{statusport}/ttstatus" );
setlog('>&STDERR', 0);
$cmd->(\%conf, @args);
exit;




# map with partition, then reduce. If reduce fails, reexecute.
sub ttmapreduce {
  my $reduced = 0;
  until($reduced){
    mappartition(@_);
    $reduced = reduce(@_);
  }
}

sub mappartition {
  my ( $conf, $k ) = @_;
  my %conf = %$conf;

  my %source = %{ corpus($conf{source}) };
  my %target = %{ corpus($conf{target}) };
  my @crew     = @{ readlist("clusters/$conf{crew}/.hosts") };
  my @ring     = @{ readlist("clusters/$target{ring}/.hosts") };
  my $targetpath = "$target{repos}/$target{nodename}"; 
  my $src_rs = "TTRS='$source{rs}'";
  my $mid_rs = exists $conf{rs} ? "TTRS='$conf{rs}'" : ''; # any RS passed is for partitioner and reducer
  my $log = logger("$crew[$k] mappartition");
  my $bin = "$targetpath/client/bin";
  
  $conf{partition} ||= 'partition';


  unless (-d "$targetpath/parts"){
    mkdir "$targetpath/parts";
    mkdir "$targetpath/parts/$_" for (0..$#ring);
  }
  
  my @localfiles = map { (m|([^/]+)$|) } glob("$source{repos}/$source{nodename}/*");
  my $in = lockloop('in', \@localfiles); 
  while ( my $chunk = $in->() ) {
    last unless @$chunk;
    my ( $name, @locations ) = @$chunk;
    my $file = "$source{repos}/$source{nodename}/$name";
    my $sig = substr( $name, 0, 32 );
    my $err = "$targetpath/client/err/$sig";

    unless (-e $file){
      statshift( free => in => $name )  && next unless @locations;
      retrieve_foreign( $file, @locations ); 
      statshift( free => in => $name )  && next unless -e "foreign/$name";
      $file = "$targetpath/client/foreign/$name";
    }
	my $catin = choosestream($file, \%source);
    my $pipe = 
      "cd $conf{context}/$conf{proj}; " .
      "$catin | $src_rs $conf{mapcmd} 2>$err | " .
      "$mid_rs $targetpath/client/bin/$conf{partition} $targetpath $name $target{ring} $target{vnodes}";

    my $retval = system $pipe;
    if( $retval ){
      $log->(0, "mapped $name with retval ". ($retval>>8) .". (Error, REVERTING)\n");
      statshift( free => in => $name );
      unlink "foreign/$name" if -e "foreign/$name";
      next;
    }

    my @parts = map { (m|/(\d+)/[^/]+$|) } glob("$targetpath/parts/*/$name");

    $log->(0, "map'd $sig to ". scalar @parts ." parts\n");
    register(part => \@parts, in => $name);
    unlink "foreign/$name" if -e "foreign/$name";

    my $errbytes = -s $err;
    if($errbytes){
      rename $err, "$err.1.$errbytes"; # undefined RS so one record per chunk
      register('err' => [ "$sig.1.$errbytes" ]);
    } else {
      unlink $err;
    }
  }
  $log->(0, "finished map tasks.\n");

}


# For each partition, sort all files in that partition by key, 
# and pipe through the reduce program to a series of segmented
# result files.
sub reduce {
  my ($conf, $k) = @_;
  my %conf = %$conf;

  my %target     = %{ corpus($conf{target}) };
  my @crew       = @{ readlist("clusters/$conf{crew}/.hosts") };
  my $targetpath = "$target{repos}/$target{nodename}";
  my $mid_rs = exists $conf{rs} ? "TTRS='$conf{rs}'" : ''; # any RS passed is for partitioner and reducer
  my $log = logger("$crew[$k] reduce");

  $log->(0, "NOT sorting.\n") if $conf{nosort};

  my @results;
  my $parts = lockloop('part');
  while(my $partobj = $parts->()){
    last unless @$partobj;
    my ($part, @sources) = @$partobj;
    $log->(0, "locked partition $part\n");

    my @frags = assemble_fragments("$targetpath/parts", $part, $k, \@crew);
    $log->(0, "got ". scalar @frags ." frags from partition $part.\n");
    statshift(free => part => $part) && next unless @frags;

    # verify all fragments are present for this partition
    my ($missing, $extra) = compare_sets(\@sources, \@frags);
    if(@$missing){
      $log->(0, scalar @$missing ." fragments missing from partition $part, skipping.\n");
      statshift( free => part => $part );
      statshift( free => in   => $_ ) for @$missing;
      return 0; # reexecute the map phase
    }

    my $err = "$targetpath/client/err/$part"; 
    $log->(0, "begin concatenating frags of partition $part\n");
#    concatfrags(FileHandle->new("cat $targetpath/parts/$part/* |"), $conf{rs}, "$targetpath/$part-sorted" );
    if(my $ret = system "sort -m -z -o $targetpath/$part-sorted $targetpath/parts/$part/*"){
      $log->(0, "Sort returned ". ($ret<<8) .", REVERTING partition $part\n");
      statshift(free => part => $part);
      next;
    }
    $log->(0, "done concatenating frags of partition $part\n");
    @frags = ("$targetpath/$part-sorted");
	my $cat = "$mid_rs $targetpath/client/bin/rmnulls $targetpath/$part-sorted";
    my $pipe = new FileHandle "cd $conf{context}/$conf{proj}; $cat | $conf{reducecmd} 2>$err |";

    my $count = seatparts($part, $pipe, \%target, $crew[$k]);
    unlink @frags;
    my $rstat = register(out => [], part => $part);
    $log->(0, "distributed reduction $part, to $count out chunks, retired with status ". $rstat->code  ."\n");

    my $errbytes = -s $err;
    if($errbytes){
      rename $err, "$err.1.$errbytes"; # undefined RS so one record per chunk
      register('err' => [ "$part.1.$errbytes" ]);
    } else {
      unlink $err;
    }
  }

  $log->(0, "finished reduce task\n");
  return 1;
}


sub ttexec {
  my ( $conf, $k ) = @_;
  my %conf = %$conf;

  my %target     = %{ corpus( $conf{target} ) };
  my @crew       = @{ $target{hosts} };
  my $targetpath = "$target{repos}/$target{nodename}";
  my $log        = logger("$crew[$k] exec");
  my $env        = "TTRS='$target{rs}' TTHOST=$k";
  my $sig        = md5_hex($crew[$k]);
  my $err        = "$targetpath/client/err/$sig";
  $log->( 0, "source lock failed" ) unless
    statshift('lock' => source => $crew[$k])->is_success;
  looseend('source lock', 
            sub { register( out => [], source => $crew[$k] ) });

  my $pipe = "cd $conf{context}/$conf{proj}; $env $conf{mapcmd} 2>$err";
  my $chunks = seatstream( $sig, FileHandle->new("$pipe|"), \%target, $crew[$k] );
  register( 'out' => [], source => $crew[$k] );
  $log->( 0, "exec finished seating $chunks chunks.\n" );

  my $errbytes = -s $err;
  if($errbytes){
    rename $err, "$err.1.$errbytes";
    register( 'err' => ["$sig.1.$errbytes"] );
  } else {
    unlink $err;
  }
  $log->( 0, "finished exec task.\n" );
}


sub compare_sets {
  my($left, $right) = @_;
  my %left  = map { $_ => 1 } @$left;
  my %right = map { $_ => 1 } @$right;

  for (@$right){
    if(exists $left{$_}){
      delete $left{$_};
      delete $right{$_};
    }
  }
  my @left  = keys %left;
  my @right = keys %right;
  return(\@left, \@right);
}


# returns an iterator for objects of the given type, starting with 
# a given list of object ids. Each object returned is garuanteed to
# be locked. Blocks until it can provide a locked object. Returns an 
# empty list ref when objects are no longer available.
sub lockloop {
  my ($type, $list) = @_;
  my @free = ();
  @free = map { [ $_ ] } @$list if defined $list;
  my $log = logger("lockloop on $type");

  return sub {
    while(1){
      while(@free){
        my $obj = shift @free;
        next unless statshift('lock' => $type => $obj->[0])->is_success;
        return $obj;
      }
      my $sleepytime = 0;
      while(1){
        my($free,$locked) = object_count($type);
        $log->(0, "$free free / $locked locked objex, exiting lockloop\n") && return [] 
          unless $free or $locked;
        if($free){
          $log->(0, "$free free / $locked locked objex\n");
          @free = object_count($type, 0); # zero means status "FREE"
          last;
        }
        $log->(0, "$free free / $locked locked objex, sleeping ". 2**$sleepytime ." seconds\n");
        sleep $sleepytime**2;
        $sleepytime++ unless $sleepytime >= 2; # 4 seconds to sleep, max
      }
    }
  };
}


# Retrieve a foreign input file to the local drive
sub retrieve_foreign {
  my($file, @hosts) = @_;
  for (@hosts){
    last unless system "$scp $_\:$file foreign/.";
  }
}

# gather fragments from hosts in randomized order
sub assemble_fragments {
  my ( $dir, $part, $thishost, $hosts ) = @_;
  my @hosts = @$hosts;
  my $ihosts = fyshuffle( $part, scalar @hosts );
  for my $i (@$ihosts) {
    system "$scp -q $hosts[$i]:$dir/$part/* $dir/$part/. 2>/dev/null";
  }
  my @parts = map { (m|([^/]+)$|) } glob("$dir/$part/*");
  return @parts;
}

# place a result on some responsible hosts
sub distribute {
  my($thishost, $file, $target) = @_;
  my %target = %$target;
  my $dest = "$target{repos}/$target{nodename}/$file";
  my $log = logger("$thishost distribute");
  my $preflist = preflist( substr($file,0,32), hashring($target{vnodes}, $target{hosts}) );
  
  my $fway = $target{replicate};
  $fway = @$preflist if (@$preflist < $fway); # can't replicate more than there are hosts
  
  my $copies = 0;
  for my $host (@$preflist){
    last if $copies >= $fway;
    my $ret = system "$scp $file $host:$dest";
    if($ret){
      $log->(0, "could not copy to $host (". ($ret>>8) .")\n");
    } else {
      $log->(0, "copied to $host\n");
      $copies++;
    }
  }
  unlink $file;
  return undef unless $copies;
  return 1;
}


# fisher-yates shuffle returns indices for an array of $size elements.
# produces same shuffle with same seed.
sub fyshuffle {
  my( $seed, $size ) = @_;
  my $array = [ 0..$size-1 ];
  srand($seed);
  my $i;
  for ( $i = @$array ; --$i ; ) {
    my $j = int rand( $i + 1 );
    next if $i == $j;
    @$array[ $i, $j ] = @$array[ $j, $i ];
  }
  return $array;
}


sub seatstream {
  my ( $sig, $fd, $conf, $thishost ) = @_;
  my %conf = %$conf;
  my $rs   = $conf{rs};
  my @hosts = @{ $conf{hosts} };

  $rs = eval $rs if ( $rs =~ /^["']/ );
  local $/ = $rs if $rs;
  my $digest = Digest::MD5->new;
  my ( $outfd, $records, $bytes );
  my $chunks = 0;
  my $log = logger("$thishost seatstream");

  # begin a new output file
  my $startoutfile = sub {
    my $stream = (exists $conf->{uncompress} ? '' : '|gzip');
    $outfd   = new FileHandle "$stream>$sig-out" or fatal($!);
    $bytes   = 0;
    $records = 0;
  };

  # do this when enough has been output
  my $endoutfile = sub {
    $outfd->close;
    $digest->addfile( new FileHandle "<$sig-out" );
    my $chunkname = $digest->hexdigest .".$records.$bytes";
    rename "$sig-out", $chunkname;
    $chunks++;
    if ($bytes > 0){ 
      distribute($thishost, $chunkname, \%conf);
      my $rstat = register( out => [ $chunkname ] );
      $log->( 0, "distributed $chunks th chunk, registered with status " . $rstat->code . "\n");
    } else { 
      my $rstat = register( out => [ $chunkname ] );
      $log->( 0, "$chunks th chunk empty, not distributing, registered with status " . $rstat->code . "\n");
      unlink $chunkname; 
    }
  };

  $startoutfile->();
  while (<$fd>) {
    $bytes += length $_;
    print $outfd $_ or fatal($!);
    $records++;
    if ( $bytes >= $conf{chunksize} ) {
      $endoutfile->();
      $startoutfile->();
    }
  }
  $endoutfile->();
  return $chunks;
}


sub seatparts {
  my ( $sig, $fd, $conf, $thishost ) = @_;
  my %conf = %$conf;
  my $rs   = $conf{rs};
  my @hosts = @{ $conf{hosts} };

  $rs = eval $rs if ( $rs =~ /^["']/ );
  local $/ = $rs if $rs;
  my ( $db, $outhandle, $records, $bytes );
  my $chunks = 0;
  my $log = logger("$thishost seatparts");
  my @hashring = @{ hashring($conf{vnodes}, \@hosts) };
  push @hashring, [ 'f' x 32, $hashring[0]->[1] ]; # add highest val vnode

  # begin a new output file
  my $startoutfile = sub {
    $db = radschunk("$sig-out"); 
    $outhandle = $db->prepare('insert into kv (k,v) values (?,?)');
    $bytes   = 0;
    $records = 0;
  };

  # do this when enough has been output
  my $endoutfile = sub {
    $db->commit;
    undef $outhandle;
    $db->disconnect;
    $log->(0, "closing out vnode for host ".$hashring[0]->[1]."\n");
    my $chunkname = $hashring[0]->[0] .".$records.$bytes";
    rename "$sig-out", $chunkname;
    $chunks++;
    if ($bytes > 0){ 
      distribute($thishost, $chunkname, \%conf);
      my $rstat = register( out => [ $chunkname ] );
      $log->( 0, "distributed chunk $chunks ($chunkname), registered with status " . $rstat->code . "\n");
    } else { 
#      my $rstat = register( out => [ $chunkname ] );
#      $log->( 0, "$chunks th chunk empty, not distributing, registered with status " . $rstat->code . "\n");
      unlink $chunkname; 
    }
  };

  $startoutfile->();
  while (<$fd>) {
    my ($key) = (m|^([^\t]+)|);
	$key = ($key =~ /^[a-f\d]{32}$/i) ? lc($key) : md5_hex($key);
    fatal("Hashring somehow empty at key $key") unless @hashring;
    if($key gt $hashring[0]->[0]){
      $endoutfile->();
      $startoutfile->();
      while(@hashring and ($key gt $hashring[0]->[0])){
        shift @hashring;
      }
      $log->(0, "found next vnode ".$hashring[0]->[0]." gt record $key\n");
    }
    $bytes += length $_;
    s/\n$//s; # hack to compensate for sqlite3 appending \n to everything
    $outhandle->execute($key, $_) or fatal($!);
    $records++;
  }
  $endoutfile->();
  return $chunks;
}


# loose ends list
{
  my %loose = ();
  my $log;
  sub looseend {
    $log ||= logger("fatal error cleanup");
    my($key, $sub) = @_;
    $log->("registered $key for cleanup");
    $loose{$key} = $sub;
  }
  sub fatal {
    while(my($k,$s) = each %loose){
      $log->("cleaning up $k");
      $s->();
    }
    exit @_;
  }
}

sub daemonize {
  my($machine, $cpu) = @_; 
  open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
  my $logname = sprintf "%020x%020x.1.0", $machine, $cpu;
  open STDOUT, ">log/$logname" or die "Can't write to client/log: $!";
  defined(my $pid = fork) or die "Can't fork: $!";
  exit if $pid;
  setsid                  or die "Can't start a new session: $!";
  open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}

