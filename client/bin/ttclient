#!/usr/bin/perl
use strict;

#    ttclient - The Robot Army client code.
#
#    Copyright (C) 2009 H5 Technologies, Ira Woodhead
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#  
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


use 5.006;
use strict;
use warnings;

use FileHandle;
use Digest::SHA1 qw{ sha1 sha1_hex };
use LWP::UserAgent;
use HTTP::Request;
use Getopt::Long;
use POSIX 'setsid';
require 'lib/shared.pl';

my $scp = 'scp -q -o "ConnectTimeout 3"';

my %conf = readconf("conf/task.conf");
my @args = @ARGV;
@ARGV = ();
my $cmd = $conf{cmd};
die "Unknown task" unless 
  (grep { $cmd eq $_ } qw{ map mapreduce exec });

$cmd = "tt$cmd";
$cmd = \&$cmd;
daemonize( @args );
setsvc( LWP::UserAgent->new, "http://$conf{master}:$conf{statusport}/ttstatus" );
setlog('>&STDERR', 0);
$cmd->(\%conf, @args);
exit;




# The simple map task.
# 
sub ttmap {
  my ($conf, $k) = @_;
  my %conf = %$conf;
  
  my %source = %{ corpus($conf{source}) };
  my %target = %{ corpus($conf{target}) };
  my @crew      = @{ readlist("clusters/$conf{crew}/.hosts") };
  my $targetpath = "$target{repos}/$target{nodename}";
  my $src_rs = "TTRS='$source{rs}'"; # a hint to the map cmd
  my $log = logger("$crew[$k] ttmap");

  my @localfiles = map { (m|([^/]+)$|) } glob("$source{repos}/$source{nodename}/*");
  my $in = lockloop('in', \@localfiles); 
  while (my $chunk = $in->()) {
    last unless @$chunk;
    my ($name, @locations) = @$chunk;
    my $file = "$source{repos}/$source{nodename}/$name";
    my $sig = substr($name,0,40);
    my $err = "$targetpath/client/err/$sig";

    unless (-e $file){
      statshift( free => in => $name )  && next unless @locations;
      retrieve_foreign( $file, @locations ); 
      statshift( free => in => $name )  && next unless -e "foreign/$name";
      $file = "$targetpath/client/foreign/$name";
    }
    my $stream = (exists $source{uncompress} ? 'cat' : 'gunzip -c');
    my $pipe = "cd $conf{context}/$conf{proj}; $stream $file | $src_rs $conf{mapcmd} 2>$err > $targetpath/$sig-mapped";

    my $retval = system $pipe;
    if( $retval ){
      $log->(0, "mapped $name with retval ". ($retval>>8) .". (Error, REVERTING)\n");
      statshift( free => in => $name );
      unlink "foreign/$name" if -e "foreign/$name";
      next;
    }

    my $count = seatstream($sig, FileHandle->new("<$targetpath/$sig-mapped"), \%target, $k);
    unlink "$targetpath/$sig-mapped";
    unlink "foreign/$name" if -e "foreign/$name";
    my $rstat = register( out => [], in => $name );
    $log->(0, "simplemap'd and distributed $name, to $count out chunks, retired with status ". $rstat->code ."\n");

    my $errbytes = -s $err;
    rename $err, "$err.1.$errbytes";
    register('err' => [ "$sig.1.$errbytes" ]);
  }
  
  $log->(0, "finished map tasks.\n");
}




# map with partition, then reduce. If reduce fails, reexecute.
sub ttmapreduce {
  my $reduced = 0;
  until($reduced){
    mappartition(@_);
    $reduced = reduce(@_);
  }
}

sub mappartition {
  my ( $conf, $k ) = @_;
  my %conf = %$conf;

  my %source = %{ corpus($conf{source}) };
  my %target = %{ corpus($conf{target}) };
  my @crew     = @{ readlist("clusters/$conf{crew}/.hosts") };
  my $targetpath = "$target{repos}/$target{nodename}"; 
  my $src_rs = "TTRS='$source{rs}'";
  my $mid_rs = exists $conf{rs} ? "TTRS='$conf{rs}'" : ''; # any RS passed is for partitioner and reducer
  my $log = logger("$crew[$k] mappartition");
  
  $conf{partition} ||= 'partition';

  unless (-d "$targetpath/parts"){
    mkdir "$targetpath/parts";
    mkdir "$targetpath/parts/$_" for (0..$#crew);
  }
  
  my @localfiles = map { (m|([^/]+)$|) } glob("$source{repos}/$source{nodename}/*");
  my $in = lockloop('in', \@localfiles); 
  while ( my $chunk = $in->() ) {
    last unless @$chunk;
    my ( $name, @locations ) = @$chunk;
    my $file = "$source{repos}/$source{nodename}/$name";
    my $sig = substr( $name, 0, 40 );
    my $err = "$targetpath/client/err/$sig";

    unless (-e $file){
      statshift( free => in => $name )  && next unless @locations;
      retrieve_foreign( $file, @locations ); 
      statshift( free => in => $name )  && next unless -e "foreign/$name";
      $file = "$targetpath/client/foreign/$name";
    }
    my $stream = (exists $source{uncompress} ? 'cat' : 'gunzip -c');
    my $pipe = 
      "cd $conf{context}/$conf{proj}; " .
      "$stream $file | $src_rs $conf{mapcmd} 2>$err | " .
      "$mid_rs $targetpath/client/bin/$conf{partition} $targetpath $name $conf{crew}";

    my $retval = system $pipe;
    if( $retval ){
      $log->(0, "mapped $name with retval ". ($retval>>8) .". (Error, REVERTING)\n");
      statshift( free => in => $name );
      unlink "foreign/$name" if -e "foreign/$name";
      next;
    }

    my @parts = map { (m|/(\d+)/[^/]+$|) } glob("$targetpath/parts/*/$name");

    $log->(0, "map'd $sig to ". scalar @parts ." parts\n");
    register(part => \@parts, in => $name);
    unlink "foreign/$name" if -e "foreign/$name";

    my $errbytes = -s $err;
    rename $err, "$err.1.$errbytes"; # undefined RS so one record per chunk
    register('err' => [ "$sig.1.$errbytes" ]);
  }
  $log->(0, "finished map tasks.\n");

}


# For each partition, sort all files in that partition by key, 
# and pipe through the reduce program to a series of segmented
# result files.
sub reduce {
  my ($conf, $k) = @_;
  my %conf = %$conf;

  my %target     = %{ corpus($conf{target}) };
  my @crew       = @{ readlist("clusters/$conf{crew}/.hosts") };
  my $targetpath = "$target{repos}/$target{nodename}";
  my $mid_rs = exists $conf{rs} ? "TTRS='$conf{rs}'" : ''; # any RS passed is for partitioner and reducer
  my $log = logger("$crew[$k] reduce");

  $log->(0, "NOT sorting.\n") if $conf{nosort};

  my @results;
  my $parts = lockloop('part');
  while(my $partobj = $parts->()){
    last unless @$partobj;
    my ($part, @sources) = @$partobj;
    $log->(0, "locked partition $part\n");

    my @frags = assemble_fragments("$targetpath/parts", $part, $k, \@crew);
    $log->(0, "got ". scalar @frags ." frags from partition $part.\n");
    statshift(free => part => $part) && next unless @frags;

    # verify all fragments are present for this partition
    my ($missing, $extra) = compare_sets(\@sources, \@frags);
    if(@$missing){
      $log->(0, scalar @$missing ." fragments missing from partition $part, skipping.\n");
      statshift( free => part => $part );
      statshift( free => in   => $_ ) for @$missing;
      return 0; # reexecute the map phase
    }

    my $err = "$targetpath/client/err/$part"; 
    my $pipe;
    unless($conf{nosort}){
      die "Sort error" if system "sort -o $targetpath/$part-sorted $targetpath/parts/$part/*";
      unlink glob("$targetpath/parts/$part/*") or warn "Problem unlinking partition $part";
      @frags = ("$targetpath/$part-sorted");
      $pipe = new FileHandle "cd $conf{context}/$conf{proj}; cat $targetpath/$part-sorted | $conf{reducecmd} 2>$err |";
    } else {
      my $ins = "$targetpath/" . join " $targetpath/", @frags;
      $pipe = new FileHandle "cd $conf{context}/$conf{proj}; cat $ins | $mid_rs $conf{reducecmd} 2>$err |";
    }

    my $count = seatstream($part, $pipe, \%target, $k);
    unlink @frags;
    my $rstat = register(out => [], part => $part);
    $log->(0, "distributed reduction $part, to $count out chunks, retired with status ". $rstat->code  ."\n");

    my $errbytes = -s $err;
    rename $err, "$err.1.$errbytes"; # undefined RS so one record per chunk
    register('err' => [ "$part.1.$errbytes" ]);
  }

  $log->(0, "finished reduce task\n");
  return 1;
}


sub ttexec {
  my ( $conf, $k ) = @_;
  my %conf = %$conf;

  my %target     = %{ corpus( $conf{target} ) };
  my @crew       = @{ $target{hosts} };
  my $targetpath = "$target{repos}/$target{nodename}";
  my $log        = logger("$crew[$k] exec");
  my $env        = "TTRS='$target{rs}' TTHOST=$k";
  my $sig        = sha1_hex($crew[$k]);
  my $err        = "$targetpath/client/err/$sig";
  $log->( 0, "source lock failed" ) unless
    statshift('lock' => source => $crew[$k])->is_success;

  my $pipe = "cd $conf{context}/$conf{proj}; $env $conf{mapcmd} 2>$err";
  my $chunks = seatstream( $sig, FileHandle->new("$pipe|"), \%target, $k );
  register( 'out' => [], source => $crew[$k] );
  $log->( 0, "exec finished seating $chunks chunks.\n" );

  my $errbytes = -s $err;
  rename $err, "$err.1.$errbytes";
  register( 'err' => ["$sig.1.$errbytes"] );
  $log->( 0, "finished exec task.\n" );
}


sub compare_sets {
  my($left, $right) = @_;
  my %left  = map { $_ => 1 } @$left;
  my %right = map { $_ => 1 } @$right;

  for (@$right){
    if(exists $left{$_}){
      delete $left{$_};
      delete $right{$_};
    }
  }
  my @left  = keys %left;
  my @right = keys %right;
  return(\@left, \@right);
}


# returns an iterator for objects of the given type, starting with 
# a given list of object ids. Each object returned is garuanteed to
# be locked. Blocks until it can provide a locked object. Returns an 
# empty list ref when objects are no longer available.
sub lockloop {
  my ($type, $list) = @_;
  my @free = ();
  @free = map { [ $_ ] } @$list if defined $list;
  my $log = logger("lockloop on $type");

  return sub {
    while(1){
      while(@free){
        my $obj = shift @free;
        next unless statshift('lock' => $type => $obj->[0])->is_success;
        return $obj;
      }
      my $sleepytime = 0;
      while(1){
        my($free,$locked) = object_count($type);
        $log->(0, "$free free / $locked locked objex, exiting lockloop\n") && return [] 
          unless $free or $locked;
        if($free){
          $log->(0, "$free free / $locked locked objex\n");
          @free = object_count($type, 0); # zero means status "FREE"
          last;
        }
        $log->(0, "$free free / $locked locked objex, sleeping ". 2**$sleepytime ." seconds\n");
        sleep $sleepytime**2;
        $sleepytime++ unless $sleepytime >= 2; # 4 seconds to sleep, max
      }
    }
  };
}


# Retrieve a foreign input file to the local drive
sub retrieve_foreign {
  my($file, @hosts) = @_;
  for (@hosts){
    my ($sig) = ($file =~ /\/([a-f\d]{40})\.\d+\.\d+$/);
    last unless system "$scp $_\:$file foreign/.";
  }
}

# gather fragments from hosts in randomized order
sub assemble_fragments {
  my ( $dir, $part, $thishost, $hosts ) = @_;
  my @hosts = @$hosts;
  my $ihosts = fyshuffle( $part, scalar @hosts );
  for my $i (@$ihosts) {
    system "$scp -q $hosts[$i]:$dir/$part/* $dir/$part/. 2>/dev/null";
  }
  my @parts = map { (m|([^/]+)$|) } glob("$dir/$part/*");
  return @parts;
}

# NOTE this leaves the source file where it is if appropriate
sub distribute {
  my($seed, $src, $dest, $k, $fway, $hosts) = @_;
  my $preflist = preflist( $seed, hashring(1, $hosts) );
  $fway = @$hosts if (@$hosts < $fway); # can't replicate more than there are hosts
  my $owngoal = 0;
  my $thishost = $hosts->[$k];
  my $log = logger("$thishost distribute");

  my $copies = 0;
  for my $target (@$preflist){
    last if $copies >= $fway;
    if (($target eq $thishost) and ($src eq $dest)){
      $log->(0, "setting owngoal for copy to myself\n");
      $owngoal = 1;
      $copies++;
      next;
    }
    my $ret = system "$scp $src $target:$dest";
    if($ret){
      $log->(0, "could not copy to $target (". ($ret>>8) .")\n");
    } else {
      $log->(0, "copied to $target\n");
      $copies++;
    }
  }
  unlink $src unless $owngoal;
  return undef unless $copies;
  return 1;
}


# fisher-yates shuffle returns indices for an array of $size elements.
# produces same shuffle with same seed.
sub fyshuffle {
  my( $seed, $size ) = @_;
  my $array = [ 0..$size-1 ];
  srand($seed);
  my $i;
  for ( $i = @$array ; --$i ; ) {
    my $j = int rand( $i + 1 );
    next if $i == $j;
    @$array[ $i, $j ] = @$array[ $j, $i ];
  }
  return $array;
}


sub seatstream {
  my ( $sig, $fd, $conf, $k ) = @_;
  my %conf = %$conf;
  my $rs   = $conf{rs};
  my @crew = @{ $conf{hosts} };

  $rs = eval $rs if ( $rs =~ /^["']/ );
  local $/ = $rs if $rs;
  my $sha = Digest::SHA1->new;
  my ( $outfd, $records, $bytes );
  my $chunks = 0;
  my $log = logger("$crew[$k] seatstream");

  # begin a new output file
  my $startoutfile = sub {
    my $stream = (exists $conf->{uncompress} ? '' : '|gzip');
    $outfd   = new FileHandle "$stream>$sig-out" or die $_;
    $bytes   = 0;
    $records = 0;
  };

  # do this when enough has been output
  my $endoutfile = sub {
    $outfd->close;
    $sha->addfile( new FileHandle "<$sig-out" );
    my $chunksig = $sha->hexdigest . ".$records.$bytes";
    rename "$sig-out", $chunksig;
    $chunks++;
    if ($bytes > 0){ 
      distribute(hex substr($chunksig,0,8), $chunksig, 
                 "$conf{repos}/$conf{nodename}/$chunksig", $k, $conf{replicate}, $conf{hosts});
      my $rstat = register( out => [ $chunksig ] );
      $log->( 0, "distributed $chunks th chunk, registered with status " . $rstat->code . "\n");
    } else { 
      my $rstat = register( out => [ $chunksig ] );
      $log->( 0, "$chunks th chunk empty, not distributing, registered with status " . $rstat->code . "\n");
      unlink $chunksig; 
    }
  };

  $startoutfile->();
  while (<$fd>) {
    $bytes += length $_;
    print $outfd $_;
    $records++;
    if ( $bytes >= $conf{chunksize} ) {
      $endoutfile->();
      $startoutfile->();
    }
  }
  $endoutfile->();
  return $chunks;
}


sub daemonize {
  my($machine, $cpu) = @_; 
  open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
  my $logname = sprintf "%020x%020x.1.0", $machine, $cpu;
  open STDOUT, ">log/$logname" or die "Can't write to client/log: $!";
  defined(my $pid = fork) or die "Can't fork: $!";
  exit if $pid;
  setsid                  or die "Can't start a new session: $!";
  open STDERR, '>&STDOUT' or die "Can't dup stdout: $!";
}





# construct a corpus type
sub corpus {
  my $corpus = shift;
  my ($cluster, $name) = cluster_and_corpus($corpus);
  my %conf;
  if( -e "clusters/$cluster/$name" ){
    %conf = readconf("clusters/$cluster/$name");
  } else {
    %conf = readconf('conf/ct.conf');
  }
  $conf{hosts} = readlist("clusters/$cluster/.hosts");
  $conf{files} = readlist("clusters/$cluster/$name.files");
  $conf{name}    = $name;
  $conf{cluster} = $cluster;
  return \%conf;
}


# nail down which cluster and corpus name
sub cluster_and_corpus {
  my $corp = shift;
  die "No corpus specified" unless $corp;
  my @spec = split /\//, $corp;
  die "cluster/corpus is malspecified: $corp" if @spec > 2;
  if(@spec == 2){
    die "No such cluster $spec[0]" unless -d "clusters/$spec[0]";
    return @spec;
  }
  my %conf = readconf('conf/ct.conf'); 
  return ($conf{cluster}, $corp) if -e "clusters/$conf{cluster}/$corp";
  my @candidates = glob("clusters/*/$corp");
  return ($conf{cluster}, $corp) if @candidates == 0; # non-existent
  die "$corp exists in multiple non-default clusters" if @candidates > 1;
  $candidates[0] =~ s|^clusters/||;
  return (split m|/|, $candidates[0]);
}

